---
title: 哈工程复试机试
date: 2022-03-08 10:23:25
tags:
    - 考研
declare: true
toc: 1
---

### 18年一志愿
求出所有的三位水仙花数
在数论中，水仙花数（Narcissistic number）[[1]](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0#cite_note-mw-1)[[2]](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0#cite_note-moore-2)，也被称为超完全数字不变数（pluperfect digital invariant, PPDI）[[3]](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0#cite_note-3)、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number）[[4]](https://zh.wikipedia.org/wiki/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0#cite_note-4) ，用来描述一个N位非负整数，其各位数字的N次方和等于该数本身。<!--more-->

**代码**
```C++
#include <cmath>
#include <iostream>

bool judge(int n) {
  int i = n;
  while (i) {
    n -= pow(i % 10, 3);
    i /= 10;
  }
  return 0 == n;
}

int main() {
  for (int i = 100; i < 1000; i++)
    if (judge(i)) std::cout << i << '\t';
  std::cout << std::endl;
  return 0;
}
```

### 18年调剂
求出范围[1,n)的所有素数之和

**代码**
```C++
#include <iostream>
using namespace std;
bool isprime(int a)//判断a是否是素数
{
    for (int i = 2; i * i <= a; i++)
        if (a % i == 0)
            return false;
    return true;
}

int main()
{
    int n, sum = 0;
    cin >> n;
    for (int i = 1; i < n; i++)
    {
        if (isprime(i))//累加范围内的所有素数
        {
            sum = sum + i;
        }
    }
    cout << sum << endl;
    return 0;
}
```

### 19年一志愿
**Description:（问题描述）**
第一行输入两个数m,n,(2<=m<n<=9999)。求出范围[m,n)内既满足非对称，又是素数的数值以及之和。
非对称：即如13，15，17......327......

**Input:(输入数据)**
从键盘输入两个整数，分别代表m,n
**Output:(输出数据)**
输出非对称素数和非对称素数之和，每个输出数据后有换行
**Sample Input:(输入实例)**
```shell
300 330
```

**Sample Output:(输出实例)**
```shell
307
311
317
935
```


**代码**
```C++
//非回文数和素数的交集
#include <iostream>
using namespace std;
#include <string.h>

bool isprime(int a) //判断a是否是素数
{
    for (int i = 2; i * i <= a; i++)
        if (a % i == 0)
            return false;
    return true;
}

bool nomirror(int a)
{ //判断a是否非对称
    string temp;
    temp = to_string(a);
    int len = temp.length();
    for (int i = 0; i < len / 2; i++)
        if (temp[i] != temp[len - i - 1])
            return true;
    return false;
}

int main()
{
    int m, n, sum = 0;
    cin >> m;
    cin >> n;
    for (int i = m; i < n; i++)
    {
        if (isprime(i) && nomirror(i))
        {
            cout << i << endl;
            sum += i;
        }
    }
    cout << sum << endl;
    return 0;
}
```

### 19年调剂
**Description:（问题描述）**
第一行输入一个数N(0<N<=10)。其次输入N个整型数。请你统计N个整型数中的负数个数和正数均值，比较两个统计数的大小。若是负数个数大，则输出负数个数；若是均值大则输出均值保留小数点后一位。(真题中是输出一些固定字符)

**Input:(输入数据)**
从键盘输入一个数N，再输入N个数
**Output:(输出数据)**
按照题意输出数值，输出数据后有换行
**Sample Input:(输入实例)**
CASE 1:
```shell
3
-5 1 2
```

CASE 2:
```shell
2
-1 -2
```

**Sample Output:(输出实例)**
CASE 1:
```shell
1.5
```

CASE 2:
```shell
2
```

**代码**
```C++
#include <iostream>
using namespace std;

int main()
{
    int N, temp;
    int zheng = 0, fu = 0, sum = 0;
    cin >> N;
    for (int i = N; i > 0; i--)
    {
        cin >> temp;
        if (temp > 0)
        {
            zheng++;
            sum += temp;
        }
        else if (temp < 0)
        {
            fu++;
        }
    }
    if (fu * zheng >= sum)
        cout << fu;
    else
    {
        float avg = (float)sum / (float)zheng;
        printf("%.1f\n", avg);
    }
    return 0;
}
```

## 一些基础小例题
### 递归进行逆序输出
```C
#include <stdio.h>
void f(int x[], int n)
{
    if (n > 1)
    {
        f(&x[1], n - 1);
        printf("%d", x[0]);
    }
    else
        printf("%d", x[0]);
}

int main()
{
    int z[6] = {1, 2, 3, 4, 5, 6};
    f(z, 6);
    printf("\n");
    return 0;
}
```
猜测上述程序最终会输出什么？？
```shell
654321

```

### 递归求最大公约数
可以采用[辗转相除法](https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352)求最大公约数
```C++
#include <iostream>
using namespace std;

int result(int a, int b)
{ //默认认为a>b,返回a和b的最大公约数
    if (a > b)
        return b ? result(b, a % b) : a;
    else
        return a ? result(a, b % a) : b;
}

int main()
{
    int x, y;
    cin >> x;
    cin >> y;
    cout << result(x, y) << endl;
    return 0;
}
```

### 汉诺塔问题


### C之指针
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main()
{
    int array[3][4] =
        {1, 2, 3,
         4, 5, 6,
         7, 8, 9,
         10, 11, 12};
    int(*pArray)[4] = array;
    printf("%d ", *(pArray[0] + 1));    //输出2
    printf("%d ", **(pArray + 1));      //输出5
    pArray++;
    printf("%d ", *(*pArray + 1));      //输出6
    return 0;
}
```

### 宏替换与宏函数的区别
```C
#include <stdio.h>
#include <stdlib.h>
#define RESULT(x) x *(x - 1)

int main()
{
    printf("%d\n", RESULT(1 + 2 + 1));
    return 0;
}
```

在宏函数中，参数是必须带括号的，本题中是没有带括号的，那么这就是一个单纯的宏替换，在做宏替换的时候切记不要把替换的值算出来，只需要单纯去替换即可:

- x的值:1+2+1

- x*(x-1): 用1+2+1替换 x 得到: 

- 1 + 2 + 1*(1 + 2 + 1-1) ,故得到我们的结果 ：6

## 读程序
### 2022-3-14
```C++
#include <stdio.h>
int fun(int *x, int n)
{
    if (n == 1)
        return x[1];
    else
        return x[1] + fun(x + 1, n - 1);
}

int main()
{

    int array[] = {0, 9, 1, 2}, res;

    res = fun(array, 3);

    printf("%d", res);
    return 0;
}
```
显然fun是一个递归函数，分析可知它的返回值是长度为n的数组x的和。所以本题输出应该是`12`.

---

```C++
#include <stdio.h>
int disp(char *str)
{
    while (*str)
    {                    //遇到'\0'结束
        putchar(*str++); // str依次往后移动
    }
    return *str;
}
int main()
{
    printf("%d", disp("NAME"));
    return 0;
}
```
注意`*str++;`等价于`*str;str++;`,而`'\0'`按照`%d`的格式输出就是数字`0`.所以最终输出应该是`NAME0`.

### 2022-3-15
