---
title: 4 种 I/O 模式：阻塞、非阻塞、同步、异步
date: 2024-07-21 02:38:51
tags:
    - C/C++
    - 网络编程
declare: true
toc: 1
---

## 阻塞、非阻塞、同步、异步

一个典型的网络 `IO` 接口调用可以分为两个阶段：**数据准备和数据读写**<!--more-->

### 1 数据准备

#### 1.1 阻塞

在阻塞 `IO` 中，调用 `IO` 方法的线程会一直等待，直到数据准备就绪。这意味着线程会被阻塞，不能执行其他任务。常见的阻塞 `IO` 函数调用如下：

```cpp
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
int size = recv(fd, buf, 1024, 0);
```

#### 1.2 非阻塞

在非阻塞 `IO` 中，调用 `IO` 方法的线程不会等待数据准备就绪，而是立即返回。线程可以继续执行其他任务，**并通过返回值判断数据是否已经准备好**。如果数据未准备好，通常会返回一个特定的错误码（例如 `EAGAIN` 或 `EWOULDBLOCK`）。

### 2 数据读写

#### 2.1 同步

通俗而言，A 操作等待 B 操作完成，得到返回值，继续处理。

> **通过 `man recv` 查看相关函数的文档**

同步 `IO` 表示数据的读写操作是由调用者（请求方）自己来完成的，无论是阻塞还是非阻塞。在同步 `IO` 中，调用者必须等待数据读写操作的完成。

#### 2.2 异步

通俗而言，A 操作告诉 B 操作它感兴趣的事件以及通知方式，然后继续处理自己的事情，B 操作在完成后通知 A 操作。

> **通过 `man aio_read` 和 `man air_write` 查看相关函数的文档**

异步 `IO` 则是调用者发出请求后，可以立即继续执行其他任务，不需要等待数据读写操作完成。当数据准备好或读写操作完成后，会通过回调函数、信号等方式通知调用者。异步 `IO` 通常需要特殊的 API 支持，例如 `aio_read` 和 `aio_write`。

**在处理 `IO` 的时候，阻塞和非阻塞都是同步 `IO`。只有使用了特殊的 API 才是异步 `IO`**

![20240616171557](https://cdn.jsdelivr.net/gh/Corner430/Picture/images/20240616171557.png)

### 3 四种 `IO` 模式

- 同步阻塞 `IO`
- 同步非阻塞 `IO`
- 异步阻塞 `IO`
- 异步非阻塞 `IO`

```cpp
/****************** 同步阻塞 *****************/

// 在同步阻塞模型中，线程会等待数据准备好，然后进行数据读写操作。
// 这是最简单的模型，也是最常见的 IO 操作方式。
int size = recv(fd, buf, 1024, 0); // 阻塞等待数据


/****************** 同步非阻塞 *****************/

// 在同步非阻塞模型中，线程不会等待数据准备好，而是立即返回。
// 并通过轮询或其他机制检查数据是否准备好。
int flags = fcntl(fd, F_GETFL, 0);
fcntl(fd, F_SETFL, flags | O_NONBLOCK);

int size = recv(fd, buf, 1024, 0);
if (size == -1 && errno == EAGAIN) {
    // 数据未准备好，稍后再试
}


/****************** 异步阻塞 *****************/

// 虽然概念上存在，但实际上异步阻塞组合是矛盾的，因为异步操作本质上应该是非阻塞的。
// 异步 IO 意味着调用者不会等待数据准备或读写操作的完成。


/****************** 异步非阻塞 *****************/

// 在异步非阻塞模型中，调用者发出 IO 请求后立即返回，不等待数据读写操作的完成。
// 当操作完成后，通过回调或信号通知调用者。
struct aiocb cb;
cb.aio_fildes = fd;
cb.aio_buf = buf;
cb.aio_nbytes = 1024;
cb.aio_offset = 0;
cb.aio_sigevent.sigev_notify = SIGEV_SIGNAL;
cb.aio_sigevent.sigev_signo = SIGUSR1;

// 发出异步读请求
aio_read(&cb);

// 处理其他逻辑，等待读写操作完成的通知
```